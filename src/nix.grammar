// FIXME
// self.overlays.default
// dots have different colors: white yellow

// FIXME
// a.xxxxxxxxxxxxx.b { c = "d"; e = f; }  # ok
// a.${xxxxxxxxxxxxx}.b { c = "d"; e = f; }  # broken

@top Nix { expression* }

expression { binaryExpr | unaryExpr | Int | Float | string | Identifier | List | AttrSet | SelectExpr | ApplyExpr | IfExpr | Bool | Null | BracesExpr | FunctionExpr | Path | AssertExpr | WithExpr | LetExpr }

binaryExpr { MulExpr | DivExpr | AddExpr | SubExpr | HasAttrExpr | ConcatListExpr | UpdateExpr | compare | equal | AndExpr | OrExpr | ImplyExpr }

unaryExpr { NegativeExpr | NotExpr }

@precedence {
  select @left,
  _list @left,
  // workaround for SubExpr/NegativeExpr conflict
  _applySub @left,
  apply @left,
  negative @left,
  hasAttr @left,
  concatList @right,
  times @left,
  plus @left,
  not @left,
  update @right,
  compare @left,
  equal @left,
  and @left,
  or @left,
  imply @right,

  // FIXME?
  pathRelative @right,
  selectOrAttrPathDot
}

@skip { whitespace | Comment | CommentBlock }

@skip {} {
  // String can be multiline, but then the indent is preserved
  // StringBlock is similar to python docstrings -> indent is removed
  string { String | StringBlock }
  StringBlock {
    stringBlockStart (StringBlockContent | StringBlockInterpolation)* stringBlockEnd
  }
  String {
    stringStart (StringContent | StringInterpolation)* stringEnd
  }
}

// TODO separate tokens for "${" and "}" of StringInterpolation etc

// ''string ${expr} ''${escaped} string''
StringBlockInterpolation { stringBlockInterpolationStart expression stringBlockInterpolationEnd }

// "string ${expr} \${escaped} string"
StringInterpolation { stringInterpolationStart expression stringInterpolationEnd }

BraceOpen { "(" }
BraceClose { ")" }
BracesExpr { BraceOpen expression BraceClose }

Mul { "*" }
MulExpr { expression !times Mul expression }

Div { "/" }
DivExpr { expression !times Div expression }

Add { "+" }
AddExpr { expression (!plus Add expression)+ }

// FIXME
// SubExpr is not used
// NegativeExpr has higher precedence than SubExpr, so 1-2 -> (1) (-2) -> ApplyExpr
// nix parser/interpreter: Nix(ApplyExpr(__sub,Int,Int))
//SubExpr { expression !plus "-" expression }

ListOpen { "[" }
ListClose { "]" }
List { ListOpen expression? (!_list expression)* ListClose }

// aka Lambda
FunctionExpr { Function expression }

Function { (Identifier | Formals) colonWithSpace }

// we need the ~curlyOpen marker
// to allow ambiguity between AttrSet and Formal
FormalsOpen { "{"}
FormalsClose { "}"}
FormalsComma { ","}
FormalsInner { (Formal? (FormalsComma Formal)* (FormalsComma FormalsRest)?) | FormalsRest }
Formals {
  (FormalsAllBefore? FormalsOpen ~curlyOpen FormalsInner FormalsClose) |
  (FormalsOpen ~curlyOpen FormalsInner FormalsClose FormalsAllAfter?)
}
FormalsAllBefore { Identifier FormalsAt }
FormalsAt { "@" }
FormalsAllAfter { FormalsAt Identifier }
FormalsRest { "..." }
Formal { Identifier FormalDefaultExpr? }
FormalDefault { "?" }
FormalDefaultExpr { FormalDefault expression }

AttrSetOpen { "{" }
AttrSetClose { "}" }
AttrSet { AttrSetOpen ~curlyOpen (attr)* AttrSetClose }
attr { Attr | InheritExpr | AttrInheritFrom }
Attr { (string | Identifier | SelectExpr) "=" expression ";" }
InheritExpr { Inherit (Identifier | SelectExpr)+ ";" }
AttrInheritFrom { InheritFromExpr (Identifier | SelectExpr)+ ";" }

InheritBraceOpen { "(" }
InheritBraceClose { ")" }
InheritFromExpr { Inherit InheritBraceOpen expression InheritBraceClose }

// need marker ~selectOrAttrPathDot for ambiguity
// between SelectDot and AttrPathDot
SelectDot { "." }
SelectExpr { (string | Identifier) !selectOrAttrPathDot SelectDot AttrPath SelectDefault? }

SelectOr { keyword<"or"> }
SelectDefault { SelectOr expression }

// we need the ~subOrNegative marker
// to allow ambiguity between Sub and Negative
// workaround for SubExpr/NegativeExpr conflict
Sub { "-" }
SubExpr { expression !_applySub Sub ~subOrNegative expression }

ApplyExpr { expression !apply expression }

Negative { "-" }
NegativeExpr { !negative Negative ~subOrNegative expression }

// TODO allow interpolation
// a.${x}.${y}
AttrPathDot { "." }
AttrPath { (string | Identifier) (!selectOrAttrPathDot AttrPathDot (string | Identifier))* }

Path { PathAbsolute | !pathRelative PathRelative | PathLibraryExpr | URI }

HasAttr { "?" }
HasAttrExpr { expression !hasAttr HasAttr AttrPath }

ConcatList { "++" }
ConcatListExpr { expression !concatList ConcatList expression }

Not { "!" }
NotExpr { Not !not expression }

Update { "//" }
UpdateExpr { expression !update Update expression }

compare { CompareGTExpr | CompareLTExpr | CompareGTEExpr | CompareLTEExpr }

CompareGT { ">" }
CompareGTExpr { expression !compare CompareGT expression }

CompareLT { "<" }
CompareLTExpr { expression !compare CompareLT expression }

CompareGTE { ">=" }
CompareGTEExpr { expression !compare CompareGTE expression }

CompareLTE { "<=" }
CompareLTEExpr { expression !compare CompareLTE expression }

equal { EqualExpr | NotEqualExpr }

Equal { "==" }
EqualExpr { expression !equal Equal expression }

NotEqual { "!=" }
NotEqualExpr { expression !equal NotEqual expression }

And { "&&" }
AndExpr { expression !and And expression }

Or { "||" }
OrExpr { expression !or Or expression }

Imply { "->" }
ImplyExpr { expression !imply Imply expression }

Identifier { identifier }

keyword<term> { @specialize[@name={term}]<identifier, term> }

Bool { True | False }

IfExpr { If expression Then expression Else expression }

AssertExprSemicolon { ";" }
AssertExpr { Assert expression AssertExprSemicolon expression }

WithExprSemicolon { ";" }
WithExpr { With expression WithExprSemicolon expression }

LetExpr { Let Attrs In expression }
Attrs { attr* }

@external tokens stringBlock from "./tokens" {
  StringBlockContent,
  stringBlockInterpolationStart,
  stringBlockEnd
}

@external tokens string from "./tokens" {
  StringContent,
  stringInterpolationStart,
  stringEnd
}

@tokens {
  Int {
    std.digit+
  }

  Float {
    ((std.digit+ "." std.digit+) | ("." std.digit+)) (("e" | "E") std.digit+)?
  }
  // fix: Overlapping tokens Int and Float
  // fix: Overlapping tokens Float and "."
  @precedence { Float, Int, "." }

  stringBlockStart { "''" }
  stringBlockInterpolationEnd { "}" }

  stringStart { '"' }
  stringInterpolationEnd { "}" }

  // note: nix allows minus in identifiers
  identifier { identifierChar (identifierChar | std.digit | "-" )* }
  identifierChar { std.asciiLetter | $[_$\u{a1}-\u{10ffff}] }

  // fix error: Overlapping tokens identifier and whitespace
  // TODO why overlapping? identifier is non-whitespace
  @precedence { identifier, whitespace }

  whitespace { std.whitespace+ }

  // FIXME no need for whitespace after formals
  // this is valid:
  // let f={a}:a; in f{a=1;}
  // let f=a: a; in f 1
  // this is not:
  // let f=a:a; in f 1 # error: attempt to call something which is not a function but a string
  Colon { ":" }
  colonWithSpace { Colon std.whitespace+ }

  CommentOpen { "#" }
  Comment { CommentOpen ![\n]* }

  // TODO CommentBlockClose */
  CommentBlockOpen { "/*" }
  CommentBlock { CommentBlockOpen blockCommentRest }
  blockCommentRest { ![*] blockCommentRest | "*" blockCommentAfterStar }
  blockCommentAfterStar { "/" | "*" blockCommentAfterStar | ![/*] blockCommentRest }

  PathAbsolute { "/" pathContent }
  // fix: Overlapping tokens "/" and PathAbsolute
  @precedence { PathAbsolute, "/" }

  PathRelative { "./" pathContent }
  // fix: Overlapping tokens PathRelative and "."
  @precedence { PathRelative, "." }

  PathLibraryExpr { "<" PathLibrary ">" }
  PathLibrary { pathContent }

  // TODO add more special characters?
  pathContent { (identifier | ".")+ ("/" (identifier | ".")+)* }

  uriSchema { std.asciiLetter (std.asciiLetter | std.digit | "+" | "-")* }
  uriPath { (std.asciiLetter | std.digit | "%" | "/" | "?" | ":" | "@" | "&" | "=" | "+" | "$" | "," | "-" | "_" | "." | "!" | "~" | "*" | "'")+ }
  URISchema { uriSchema }
  URIPath { uriPath }
  URI { URISchema ":" URIPath }

  // fix: Overlapping tokens identifier and URI
  @precedence { URI, identifier }

  If { "if" }
  Then { "then" }
  Else { "else" }
  Assert { "assert" }
  With { "with" }
  Let { "let" }
  In { "in" }
  Inherit { "inherit" }

  False { "false" }
  True { "true" }
  Null { "null" }

  // fix: Overlapping tokens identifier and x
  @precedence {
    If, Then, Else,
    Assert, With, Let, In,
    Inherit,
    URI,
    False, True, Null,
    identifier
  }
}
