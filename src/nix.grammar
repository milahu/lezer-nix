// FIXME
// self.overlays.default
// dots have different colors: white yellow

// FIXME
// a.xxxxxxxxxxxxx.b { c = "d"; e = f; }  # ok
// a.${xxxxxxxxxxxxx}.b { c = "d"; e = f; }  # broken

@top Nix { expression? }

expression {
  Integer |
  Float |
  If |
  bool |
  Null |
  Identifier |

  string |
  Path |

  Braces |
  List |
  AttrSet |
  Select |

  Assert |
  With |
  Let

  Apply |
  unary |
  binary |
  Function
}

binary {
  Mul |
  Div |
  Add |
  // Sub | // not used
  HasAttr |
  ConcatList |
  Update |
  compare |
  Equal |
  NotEqual |
  And |
  Or |
  Imply
}

unary {
  Negative |
  Not
}

@precedence {
  select @left,
  _list @left,
  // workaround for Sub/Negative conflict
  _applySub @left,
  apply @left,
  negative @left,
  hasAttr @left,
  concatList @right,
  times @left,
  plus @left,
  not @left,
  update @right,
  compare @left,
  equal @left,
  and @left,
  or @left,
  imply @right,

  // FIXME?
  pathRelative @right,
  selectOrAttrPathDot
}

@skip {
  whitespace |
  Comment |
  CommentBlock
}

@skip {} {
  // String can be multiline, but then the indent is preserved
  // StringBlock is similar to python docstrings -> indent is removed
  string { String | StringBlock }
  StringBlock {
    stringBlockStart (StringBlockContent | StringBlockInterpolation)* stringBlockEnd
  }
  String {
    stringStart (StringContent | StringInterpolation)* stringEnd
  }
}

// TODO separate tokens for "${" and "}" of StringInterpolation etc

// ''string ${expr} ''${escaped} string''
StringBlockInterpolation { stringBlockInterpolationStart expression stringBlockInterpolationEnd }

// "string ${expr} \${escaped} string"
StringInterpolation { stringInterpolationStart expression stringInterpolationEnd }

braceOpen { "(" }
braceClose { ")" }
Braces { braceOpen expression braceClose }

mul { "*" }
Mul { expression !times mul expression }

div { "/" }
Div { expression !times div expression }

add { "+" }
//Add { expression (!plus add expression)+ }
// Add is binary
Add { expression !plus add expression }

// Sub is not used
// Negative has higher precedence than Sub, so 1-2 -> (1) (-2) -> Apply
// nix parser/interpreter: Nix(Apply(__sub,Integer,Integer))
//sub { "-" }
//Sub { expression !plus sub expression }

listOpen { "[" }
listClose { "]" }
List { listOpen expression? (!_list expression)* listClose }

// aka Lambda
Function { functionArgument expression }
functionArgument { (Identifier | Formals) colonWithSpace }

// we need the ~curlyOpen marker
// to allow ambiguity between AttrSet and Formal
Formals {
  (FormalsBindBefore? formalsOpen ~curlyOpen formalsInner formalsClose) |
  (formalsOpen ~curlyOpen formalsInner formalsClose FormalsBindAfter?)
}
formalsOpen { "{" }
formalsClose { "}" }
formalsComma { "," }
formalsInner { (Formal? (formalsComma Formal)* (formalsComma FormalsRest)?) | FormalsRest }
FormalsBindBefore { Identifier formalsAt }
FormalsBindAfter { formalsAt Identifier }
formalsAt { "@" }
FormalsRest { "..." }
Formal { Identifier FormalDefault? }
formalDefault { "?" }
FormalDefault { formalDefault expression }

AttrSet { attrSetOpen ~curlyOpen (attr)* attrSetClose }
attrSetOpen { "{" }
attrSetClose { "}" }
attr { Attr | AttrInherit | AttrInheritFrom }
Attr { (string | Identifier | Select) "=" expression ";" }
AttrInherit { inherit (Identifier | Select)+ ";" }
AttrInheritFrom { "(" expression ")" (Identifier | Select)+ ";" }

// need marker ~selectOrAttrPathDot for ambiguity
// between SelectDot and AttrPathDot
selectDot { "." }
Select { (string | Identifier) !selectOrAttrPathDot selectDot AttrPath SelectDefault? }

selectOr { keyword<"or"> }
SelectDefault { selectOr expression }

// we need the ~subOrNegative marker
// to allow ambiguity between Sub and Negative
// workaround for Sub/Negative conflict
//Sub { "-" }
//Sub { expression !_applySub Sub ~subOrNegative expression }

// TODO more specific than expression?
Apply { expression !apply expression }

negative { "-" }
//Negative { !negative negative ~subOrNegative expression }
Negative { !negative negative expression }

// TODO allow interpolation
// a.${x}.${y}
attrPathDot { "." }
AttrPath { (string | Identifier) (!selectOrAttrPathDot attrPathDot (string | Identifier))* }

Path { PathAbsolute | !pathRelative PathRelative | PathLibrary | Uri }

hasAttr { "?" }
HasAttr { expression !hasAttr hasAttr AttrPath }

concatList { "++" }
ConcatList { expression !concatList concatList expression }

not { "!" }
Not { not !not expression }

update { "//" }
Update { expression !update update expression }

compare { CompareGT | CompareLT | CompareGTE | CompareLTE }

compareGT { ">" }
CompareGT { expression !compare compareGT expression }

compareLT { "<" }
CompareLT { expression !compare compareLT expression }

compareGTE { ">=" }
CompareGTE { expression !compare compareGTE expression }

compareLTE { "<=" }
CompareLTE { expression !compare compareLTE expression }

equal { "==" }
Equal { expression !equal equal expression }

notEqual { "!=" }
NotEqual { expression !equal notEqual expression }

and { "&&" }
And { expression !and and expression }

or { "||" }
Or { expression !or or expression }

imply { "->" }
Imply { expression !imply imply expression }


bool { True | False }
// i need True False Null for my evaluator
//Boolean { @specialize<Identifier, "true" | "false"> }
True { @specialize<Identifier, "true"> }
False { @specialize<Identifier, "false"> }
Null { @specialize<Identifier, "null"> }

//If { if expression then expression else expression }
//IfExpr { kw<'if'> expression kw<'then'> expression kw<'else'> expression }
If { kw<'if'> expression kw<'then'> expression kw<'else'> expression }

//assertSemicolon { ";" }
//Assert { assert expression assertSemicolon expression }
//Assert { kw<"assert"> expression ";" exprFunction }

// FIXME keyword "assert" should be anonymous
Assert { kw<"assert"> expression ";" expression }


exprFunction {
  Function |
  Assert |
  With |
  Let |
  exprIf
}

//withSemicolon { ";" }
//With { with expression withSemicolon expression }
//With { kw<"with"> expression ";" exprFunction }
With { kw<"with"> expression ";" expression }

//Let { let Attrs in expression }
//Attrs { attr* }
//Let { kw<"let"> binds? kw<"in"> exprFunction }
Let { kw<"let"> binds? kw<"in"> expression }


binds { (Bind | inherit | inheritFrom)+ }
Bind { AttrPath "=" expression ";" }
inherit { kw<"inherit"> attrsInherited ";" }
inheritFrom { kw<"inherit"> "(" expression ")" attrsInherited ";" }


@external tokens stringBlock from "./tokens" {
  StringBlockContent,
  stringBlockInterpolationStart,
  stringBlockEnd
}

@external tokens string from "./tokens" {
  StringContent,
  stringInterpolationStart,
  stringEnd
}

@tokens {
  Integer { std.digit+ }
  Float { ((std.digit+ "." std.digit+) | ("." std.digit+)) (("e" | "E") std.digit+)? }
  // fix: Overlapping tokens Integer and Float
  // fix: Overlapping tokens Float and "."
  @precedence { Float, Integer, "." }

  stringBlockStart { "''" }
  stringBlockInterpolationEnd { "}" }

  stringStart { '"' }
  stringInterpolationEnd { "}" }

  // note: nix allows minus in identifiers
  Identifier { identifierChar (identifierChar | std.digit | "-" )* }

  // TODO test
  //identifierChar { std.asciiLetter | $[_$\u{a1}-\u{10ffff}] }
  identifierChar { std.asciiLetter }

  // fix error: Overlapping tokens Identifier and whitespace
  // TODO why overlapping? Identifier is non-whitespace
  @precedence { Identifier, whitespace }

  whitespace { std.whitespace+ }

  // FIXME no need for whitespace after formals
  // this is valid:
  // let f={a}:a; in f{a=1;}
  // let f=a: a; in f 1
  // this is not:
  // let f=a:a; in f 1 # error: attempt to call something which is not a function but a string
  Colon { ":" }
  colonWithSpace { Colon std.whitespace+ }

  CommentOpen { "#" }
  Comment { CommentOpen ![\n]* }

  // TODO CommentBlockClose */
  CommentBlockOpen { "/*" }
  CommentBlock { CommentBlockOpen blockCommentRest }
  blockCommentRest { ![*] blockCommentRest | "*" blockCommentAfterStar }
  blockCommentAfterStar { "/" | "*" blockCommentAfterStar | ![/*] blockCommentRest }

  PathAbsolute { "/" pathContent }
  // fix: Overlapping tokens "/" and PathAbsolute
  @precedence { PathAbsolute, "/" }

  PathRelative { "./" pathContent }
  // fix: Overlapping tokens PathRelative and "."
  @precedence { PathRelative, "." }

  // TODO angle braces as tokens
  PathLibrary { "<" PathLibraryValue ">" }
  PathLibraryValue { pathContent }

  // TODO add more special characters?
  pathContent { (Identifier | ".")+ ("/" (Identifier | ".")+)* }

  uriSchema { std.asciiLetter (std.asciiLetter | std.digit | "+" | "-")* }
  uriPath { (std.asciiLetter | std.digit | "%" | "/" | "?" | ":" | "@" | "&" | "=" | "+" | "$" | "," | "-" | "_" | "." | "!" | "~" | "*" | "'")+ }
  Uri { uriSchema ":" uriPath }

  // fix: Overlapping tokens Identifier and Uri
  @precedence { Uri, Identifier }

  // fix: Overlapping tokens Identifier and x
  // better?
  // kw<word> { @specialize[@name={word}]<Identifier, word> }
  @precedence {
    //if, then, else,
    //assert,
    //with,
    //let,
    //in,
    //inherit,
    //Uri,
    //False, True, Null,
    //Identifier
  }
}



// based on codemirror-lang-nix/src/syntax.grammar

// named tokens
//kw<word> { @specialize[@name={word}]<Identifier, word> }
//keyword<term> { @specialize[@name={term}]<Identifier, term> }

// anonymous tokens
kw<word> { @specialize<Identifier, word> }
keyword<term> { @specialize<Identifier, term> }

attrsInherited {
  (Identifier | String | Interpolation<"${">)+
}

Interpolation<start> { start expression "}" }

exprIf {
  //IfExpr |
  If |
  exprOp
}

exprOp {
  binary |
  unary |
  exprApp
}

exprApp {
  Apply |
  exprSelect
}

exprSelect {
  Select
  // | exprSimple
}

exprSimple {
  Identifier |
  kw<"builtins"> |
  Null |
  Integer |
  Float |

  // FIXME? reduce/reduce conflict
  // Boolean |
  //True |
  //False |
  //String |
  //StringBlock |

  Path |
  // HPath |
  // SPath |
  // URI |
  Parenthesized |
  AttrSet |
  //LetAttrSet | # TODO
  //RecAttrSet | # TODO
  List
}

Parenthesized { "(" expression ")" }
