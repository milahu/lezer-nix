@top Nix { expression* }

expression { binaryExpr | unaryExpr | Int | Float | string | Identifier | List | AttrSet | Select | Apply | If | boolean | null | Braces | Function | path }

binaryExpr { Mul | Div | Add | Sub | HasAttr | ConcatList | Update | compare | equal | And | Or | Imply }

unaryExpr { Negative | Not }

@precedence {
  select @left,
  _list @left,
  // workaround for Sub/Negative conflict
  _applySub @left,
  apply @left,
  negative @left,
  hasAttr @left,
  concatList @right,
  times @left,
  plus @left,
  not @left,
  update @right,
  compare @left,
  equal @left,
  and @left,
  or @left,
  imply @right
}

@skip { whitespace | CommentLine | CommentBlock }

@skip {} {
  // StringLine can be multiline, but then the indent is preserved
  // StringBlock is similar to python docstrings -> indent is removed
  string { StringLine | StringBlock }
  StringBlock {
    stringBlockStart (StringBlockContent | StringBlockInterpolation)* stringBlockEnd
  }
  StringLine {
    stringLineStart (StringLineContent | StringLineInterpolation)* stringLineEnd
  }
}

// ''string ${expr} ''${escaped} string''
StringBlockInterpolation { stringBlockInterpolationStart expression stringBlockInterpolationEnd }

// "string ${expr} \${escaped} string"
StringLineInterpolation { stringLineInterpolationStart expression stringLineInterpolationEnd }

Braces { "(" expression ")" }

Mul { expression !times "*" expression }
Div { expression !times "/" expression }

Add { expression (!plus "+" expression)+ }

// FIXME
// Sub is not used
// Negative has higher precedence than Sub, so 1-2 -> (1) (-2) -> Apply
// nix parser/interpreter: Nix(Apply(__sub,Int,Int))
//Sub { expression !plus "-" expression }

List { "[" expression? (!_list expression)* "]" }

// aka Lambda
Function { functionArgument expression }

functionArgument { (Identifier | Formals) colonWithSpace }

Formals {
  FormalsAllBefore? "{" ((Formal? ("," Formal)* ("," FormalsRest)?) | FormalsRest) "}" |
  "{" ((Formal? ("," Formal)* ("," FormalsRest)?) | FormalsRest) "}" FormalsAllAfter?
}
FormalsAllBefore { Identifier "@" }
FormalsAllAfter { "@" Identifier }
FormalsRest { "..." }
Formal { Identifier FormalDefault? }
FormalDefault { "?" expression }

AttrSet { "{" (Attr)* "}" }

Attr { (string | Identifier | Select) "=" expression ";" }

Select { (string | Identifier) "." AttrPath SelectDefault? }
SelectDefault { keyword<"or"> expression }

// workaround for Sub/Negative conflict
Sub { expression !_applySub "-" expression }

Apply { expression !apply expression }

Negative { !negative "-" expression }

// TODO allow interpolation
// a.${x}.${y}
AttrPath { (string | Identifier) ("." (string | Identifier))* }

path { PathAbsolute | PathRelative | PathLibrary | URI }

HasAttr { expression !hasAttr "?" AttrPath }

ConcatList { expression !concatList "++" expression }

Not { "!" !not expression }

Update { expression !update "//" expression }

compare { CompareGT | CompareLT | CompareGTE | CompareLTE }
CompareGT { expression !compare ">" expression }
CompareLT { expression !compare "<" expression }
CompareGTE { expression !compare ">=" expression }
CompareLTE { expression !compare "<=" expression }

equal { Equal | NotEqual }
Equal { expression !equal "==" expression }
NotEqual { expression !equal "!=" expression }

And { expression !and "&&" expression }

Or { expression !or "||" expression }

Imply { expression !imply "->" expression }

// TODO better
Identifier { identifier }

keyword<term> { @specialize[@name={term}]<identifier, term> }

boolean { @specialize[@name=BooleanLiteral]<identifier, "true" | "false"> }

null { @specialize[@name=NullLiteral]<identifier, "null"> }

If { keyword<"if"> expression keyword<"then"> expression keyword<"else"> expression }

@external tokens stringBlock from "./tokens" {
  StringBlockContent,
  stringBlockInterpolationStart,
  stringBlockEnd
}

@external tokens stringLine from "./tokens" {
  StringLineContent,
  stringLineInterpolationStart,
  stringLineEnd
}

@tokens {
  Int {
    std.digit+
  }

  Float {
    ((std.digit+ "." std.digit+) | ("." std.digit+)) (("e" | "E") std.digit+)?
  }
  // fix: Overlapping tokens Int and Float
  // fix: Overlapping tokens Float and "."
  @precedence { Float, Int, "." }

  stringBlockStart { "''" }
  stringBlockInterpolationEnd { "}" }

  stringLineStart { '"' }
  stringLineInterpolationEnd { "}" }

  identifier { identifierChar (identifierChar | std.digit)* }
  identifierChar { std.asciiLetter | $[_$\u{a1}-\u{10ffff}] }

  // fix error: Overlapping tokens identifier and whitespace
  // TODO why overlapping? identifier is non-whitespace
  @precedence { identifier, whitespace }

  whitespace { std.whitespace+ }

  colonWithSpace { ":" std.whitespace+ }

  CommentLine { "#" ![\n]* }

  CommentBlock { "/*" blockCommentRest }
  blockCommentRest { ![*] blockCommentRest | "*" blockCommentAfterStar }
  blockCommentAfterStar { "/" | "*" blockCommentAfterStar | ![/*] blockCommentRest }

  PathAbsolute { "/" PathContent }
  // fix: Overlapping tokens "/" and PathAbsolute
  @precedence { PathAbsolute, "/" }

  PathRelative { "./" PathContent }
  // fix: Overlapping tokens PathRelative and "."
  @precedence { PathRelative, "." }

  PathLibrary { "<" PathContent ">" }

  // TODO produce extra token PathContent
  PathContent { identifier ("/" identifier)* }

  URI { uriSchema ":" uriPath }

  uriSchema { std.asciiLetter (std.asciiLetter | std.digit | "+" | "-")* }

  uriPath { (std.asciiLetter | std.digit | "%" | "/" | "?" | ":" | "@" | "&" | "=" | "+" | "$" | "," | "-" | "_" | "." | "!" | "~" | "*" | "'")+ }

  // fix: Overlapping tokens identifier and URI
  @precedence { URI, identifier }
}
