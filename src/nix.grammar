// Nix grammar for lezer-parser. MIT License (c) 2022 Milan Hauth

@top Nix { expr? }

expr
  { Lambda { Identifier ':' expr }
  | Lambda { '{' ~markCurlyOpen formals '}' ':' expr }
  | Lambda { '{' ~markCurlyOpen formals '}' '@' Identifier ':' expr }
  | Lambda { Identifier '@' '{' ~markCurlyOpen formals '}' ':' expr }
  | Assert { _ASSERT expr ';' expr }
  | With { _WITH expr ';' expr }
  | Let { _LET bindings _IN expr } // syntax sugar: let a=1; in a -> (rec {a=1;}).a
  | expr_if
  }

expr_if
  { If { _IF expr _THEN expr _ELSE expr }
  | expr_op
  }

expr_op
  { OpNot         {                        '!' expr_op !prec_not }
  | CallNeg       {                        '-' expr_op !prec_neg }
  | OpEq          { expr_op !prec_equal   '==' expr_op }
  | OpNEq         { expr_op !prec_equal   '!=' expr_op }
  | CallLT        { expr_op !prec_compare '<'  expr_op }
  | CallLE        { expr_op !prec_compare '<=' expr_op }
  | CallGT        { expr_op !prec_compare '>'  expr_op }
  | CallGE        { expr_op !prec_compare '>=' expr_op }
  | OpAnd         { expr_op !prec_and     '&&' expr_op }
  | OpOr          { expr_op !prec_or      '||' expr_op }
  | OpImpl        { expr_op !prec_impl    '->' expr_op }
  | OpUpdate      { expr_op !prec_update  '//' expr_op }
  | OpHasAttr     { expr_op !prec_hasAttr  '?' attrpath }
  | ConcatStrings { expr_op !prec_plus     '+' expr_op } // concat strings, Add
  | CallSub       { expr_op !prec_callSub  '-' expr_op }
  | CallMul       { expr_op !prec_mul_div  '*' expr_op }
  | CallDiv       { expr_op !prec_mul_div  '/' expr_op }
  | OpConcatLists { expr_op !prec_concat  '++' expr_op } // concat lists
  | expr_app
  }

expr_app
  { Call { expr_app !prec_apply expr_select }
  | expr_select
  }

expr_select
  { Select { expr_simple !prec_select '.' attrpath }
  | SelectOr { expr_simple !prec_select '.' attrpath _OR_KW expr_select }
  | expr_simple
  }

expr_simple
  { Pos { keyword<"__curPos"> }
  | Var { Identifier }
  | Primop { primop }
  | Int { integer }
  | Float { float }
  | TRUE
  | FALSE
  | NULL
  | String { string_parts }
  | IndentedString { ind_string_parts }
  | Path { path_start }
  //| CallStringPath { SPATH } // TODO what is StringPath?
  | String { URI } // note: if noURLLiterals: ParseError, URL literals are disabled
  | Parens { '(' expr ')' }
  | RecAttrSet { _REC '{' ~markCurlyOpen bindings '}' }
  | AttrSet { '{'~markCurlyOpen bindings '}' } // TODO not needed ~curlyOpen marker? // AttrSet { "{" ~curlyOpen (attr)* "}" }
  | List { '[' (expr_simple (!prec_list expr_simple)*)? ']' }
  }

@precedence {
  prec_select @left,
  prec_list @left,
  prec_callSub @left, // workaround for Sub/Negative conflict
  prec_apply @left,
  prec_neg @left,
  prec_hasAttr @left,
  prec_concat @right,
  prec_mul_div @left,
  prec_plus @left,
  prec_not @left,
  prec_update @right,
  prec_compare @left,
  prec_equal @left,
  prec_and @left,
  prec_or @left,
  prec_impl @right,

  // FIXME?
  prec_pathRelative @right,
  prec_selectOrAttrPathDot
}

@skip {
  whitespace |
  Comment |
  CommentBlock
}



// strings

StringInterpolation
  { stringInterpolationStart expr stringInterpolationEnd
  }

StringBlockInterpolation
  { stringBlockInterpolationStart expr stringBlockInterpolationEnd
  }

@external tokens string from "./tokens" {
  StringContent,
  stringInterpolationStart,
  stringEnd
}

@external tokens stringBlock from "./tokens" { // aka: indented string
  StringBlockContent,
  stringBlockInterpolationStart,
  stringBlockEnd
}

@skip {} {

  string_parts
    { concatStrings { string_parts_interpolated }
    }

  ind_string_parts
    { stringBlockStart (StringBlockContent | StringBlockInterpolation)* stringBlockEnd
    }

  string_parts_interpolated
    { stringStart (StringContent | StringInterpolation)* stringEnd
    }
}

// FIXME name: remove "start"
path_start
  { ___Path { PathAbsolute | !prec_pathRelative PathRelative | PathLibrary | PathHome }
  }



// attribute sets

// note: Attr value is positional -> last child node
// {a=1;} -> Nix(AttrSet(Attr(Identifier,Int)))

bindings
  { _Attrs
    {
      ( Attr { attrpath '=' expr ';' }
      | AttrInherit { _INHERIT attrs ';' }
      | AttrInheritFrom { _INHERIT '(' expr ')' attrs ';' } // !!! Should ensure sharing of the expression in $4.
      )*
    }
  }

// FIXME token name AttrPath
// should be _AttrList?
attrs
  //{ AttrPath { ( _AttrName_String { string_attr } )* }
  { _AttrPath { ( _AttrName_String { attrpath } )* }
  }

// a.b."c".${d}
//  |^^^^^^^^^^ attrpath
//  ^ select

attrpath
  { _AttrName { ((attr | string_attr) ('.' (attr | string_attr))*) }
  }

attr
  { Identifier }

string_attr
  { String { string_parts }
  | AttrInterpolation { '${' expr '}' }
  }

formals
  { Formals { (formal? (',' formal)* (',' '...')?) | '...' }
  }

formal
  { Formal { Identifier }
  | Formal { Identifier '?' expr }
  }



// keywords

// underscore or lowercase prefix -> anonymous token

keyword<term> { @specialize<Identifier, term> }

TRUE { keyword<"true"> }
FALSE { keyword<"false"> }
NULL { keyword<"null"> }

_ASSERT { keyword<"assert"> }
_IF { keyword<"if"> }
_THEN { keyword<"then"> }
_ELSE { keyword<"else"> }

_WITH { keyword<"with"> }
_LET { keyword<"let"> }
_IN { keyword<"in"> }
_OR_KW { keyword<"or"> }
_INHERIT { keyword<"inherit"> }
_REC { keyword<"rec"> }



@tokens {
  integer { std.digit+ }
  float   { ((std.digit+ "." std.digit+) | ("." std.digit+)) (("e" | "E") std.digit+)? }
  @precedence { float, integer, "." }

  Identifier { identifierChar (identifierChar | std.digit | "-" )* } // note: nix allows minus in identifiers
  @precedence { Identifier, whitespace }

  // TODO test unicode identifiers
  // FIXME Overlapping tokens Identifier and "${" used in same context (example: "$" vs "${")
  //identifierChar { std.asciiLetter | $[_$\u{a1}-\u{10ffff}] }
  identifierChar { std.asciiLetter }

  stringBlockStart { "''" }
  stringBlockInterpolationEnd { "}" }

  stringStart { '"' }
  stringInterpolationEnd { "}" }

  whitespace { std.whitespace+ }

  CommentOpen { "#" }
  Comment { CommentOpen ![\n]* }

  // TODO? CommentBlockClose "*/" -> external scanner
  CommentBlockOpen { "/*" }
  CommentBlock { CommentBlockOpen blockCommentRest }
  blockCommentRest { ![*] blockCommentRest | "*" blockCommentAfterStar }
  blockCommentAfterStar { "/" | "*" blockCommentAfterStar | ![/*] blockCommentRest }

  PathAbsolute { "/" pathContent }
  @precedence { PathAbsolute, "/" }

  PathRelative { "./" pathContent }
  @precedence { PathRelative, "." }

  PathHome { "~/" pathContent }

  PathLibrary { "<" PathLibraryValue ">" }
  PathLibraryValue { pathContent }

  // TODO add more special characters? unicode?
  pathContent { (Identifier | ".")+ ("/" (Identifier | ".")+)* }

  URI { uriSchema ":" uriPath }
  uriSchema { std.asciiLetter (std.asciiLetter | std.digit | "+" | "-")* }
  uriPath { (std.asciiLetter | std.digit | "%" | "/" | "?" | ":" | "@" | "&" | "=" | "+" | "$" | "," | "-" | "_" | "." | "!" | "~" | "*" | "'")+ }
  @precedence { URI, Identifier }
}



// cat nix/src/libexpr/primops.cc | grep '.name = "__' | cut -d'"' -f2 | sed -E 's/^(.*)$/  | "\1"/'

primop
  { "__typeOf"
  | "__isFunction"
  | "__isInt"
  | "__isFloat"
  | "__isString"
  | "__isBool"
  | "__isPath"
  | "__genericClosure"
  | "__addErrorContext"
  | "__ceil"
  | "__floor"
  | "__tryEval"
  | "__getEnv"
  | "__seq"
  | "__deepSeq"
  | "__trace"
  | "__toPath"
  | "__storePath"
  | "__pathExists"
  | "__readFile"
  | "__findFile"
  | "__hashFile"
  | "__readDir"
  | "__toXML"
  | "__toJSON"
  | "__fromJSON"
  | "__toFile"
  | "__filterSource"
  | "__path"
  | "__attrNames"
  | "__attrValues"
  | "__getAttr"
  | "__unsafeGetAttrPos"
  | "__hasAttr"
  | "__isAttrs"
  | "__listToAttrs"
  | "__intersectAttrs"
  | "__catAttrs"
  | "__functionArgs"
  | "__mapAttrs"
  | "__zipAttrsWith"
  | "__isList"
  | "__elemAt"
  | "__head"
  | "__tail"
  | "__filter"
  | "__elem"
  | "__concatLists"
  | "__length"
  | "__foldl'"
  | "__any"
  | "__all"
  | "__genList"
  | "__sort"
  | "__partition"
  | "__groupBy"
  | "__concatMap"
  | "__add"
  | "__sub"
  | "__mul"
  | "__div"
  | "__bitAnd"
  | "__bitOr"
  | "__bitXor"
  | "__lessThan"
  | "__substring"
  | "__stringLength"
  | "__hashString"
  | "__match"
  | "__split"
  | "__concatStringsSep"
  | "__replaceStrings"
  | "__parseDrvName"
  | "__compareVersions"
  | "__splitVersion"
  | "__traceVerbose"
  }
