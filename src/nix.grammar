// Nix grammar for lezer-parser
// MIT License (c) 2022 Milan Hauth

@top Nix { expr? }

expr { expr_function }

expr_function
  { ExprLambda { Identifier ':' expr_function }
  //| ExprLambda { '{' formals '}' ':' expr_function }
  //| ExprLambda { '{' formals '}' '@' Identifier ':' expr_function }
  //| ExprLambda { Identifier '@' '{' formals '}' ':' expr_function }
  | ExprAssert { _ASSERT expr ';' expr_function }
  //| ExprWith { WITH expr ';' expr_function }
/////// TODO  | ExprLet { LET binds IN expr_function }
  | expr_if
  }

expr_if
  { ExprIf { _IF expr _THEN expr _ELSE expr }
  | expr_op
  }

expr_op
  { ExprOpNot         {                        '!' expr_op !prec_not }
  | ExprCallNeg       {                        '-' expr_op !prec_neg }
  | ExprOpEq          { expr_op !prec_equal   '==' expr_op }
  | ExprOpNEq         { expr_op !prec_equal   '!=' expr_op }
  | ExprCallLT        { expr_op !prec_compare '<'  expr_op }
  | ExprCallLE        { expr_op !prec_compare '<=' expr_op }
  | ExprCallGT        { expr_op !prec_compare '>'  expr_op }
  | ExprCallGE        { expr_op !prec_compare '>=' expr_op }
  | ExprOpAnd         { expr_op !prec_and     '&&' expr_op }
  | ExprOpOr          { expr_op !prec_or      '||' expr_op }
  | ExprOpImpl        { expr_op !prec_impl    '->' expr_op }
  | ExprOpUpdate      { expr_op !prec_update  '//' expr_op }

// TODO
//  | ExprOpHasAttr     { expr_op !prec_hasAttr  '?' attrpath }

  | ExprConcatStrings { expr_op !prec_plus     '+' expr_op } // concat strings, Add
  | ExprCallSub       { expr_op !prec_callSub  '-' expr_op }
  | ExprCallMul       { expr_op !prec_mul_div  '*' expr_op }
  | ExprCallDiv       { expr_op !prec_mul_div  '/' expr_op }
  | ExprOpConcatLists { expr_op !prec_concat  '++' expr_op } // concat lists
  | expr_app
  }


expr_app
  {
    //ExprCall { expr_app !prec_apply expr_select }
    //|
    expr_select
  }
//
expr_select
  {
    //ExprSelect { expr_simple !prec_select '.' attrpath }
    //| ExprSelect { expr_simple !prec_select '.' attrpath keyword<"or"> expr_select }

  // Backwards compatibility: because Nixpkgs has a rarely used
  // function named ‘or’, allow stuff like ‘map or [...]’.
  //| ExprCallOr { expr_simple keyword<"or"> }

  //|
  expr_simple // TODO expr_simple { $$ = $1; }
  }

expr_simple
  //{ ExprPos { "__curPos" }
  { ExprPos { keyword<"__curPos"> }
  | ExprVar { Identifier }
  | ExprInt { integer }
  | ExprFloat { float }

  | TRUE
  | FALSE
  | NULL

//  | ExprBool { True { _TRUE } | False { _FALSE } }
//  | ExprNull { Null { _NULL } }

//| ExprBool { _TRUE | _FALSE }
//
//_TRUE { keyword<"true"> }
//_FALSE { keyword<"false"> }
//_NULL { keyword<"null"> }

// FIXME strings
//  //| String { '"' string_parts '"' }
//  | String { string_parts }
//  //| IndentedString { IND_STRING_OPEN ind_string_parts IND_STRING_CLOSE }
//  | IndentedString { ind_string_parts }
//  | Path { path_start PATH_END } // TODO path_start PATH_END { $$ = $1; }
//  | ExprConcatStrings { path_start string_parts_interpolated PATH_END }
//  //// TODO what is SPATH? // | ExprCallStringPath { SPATH }
//  | ExprString { URI } // NOTE: if noURLLiterals: ParseError, URL literals are disabled

  | ExprParens { '(' expr ')' }

  // Let expressions `let {..., body = ...}' are just desugared
  // into `(rec {..., body = ...}).body'.
/////////// TODO  | ExprSelectLetAttrSet { LET '{' binds '}' }
//
//  | ExprRecAttrSet { REC '{' binds '}' }
//  | ExprAttrSet { '{' binds '}' } // TODO not needed ~curlyOpen marker? // AttrSet { "{" ~curlyOpen (attr)* "}" }
  | ExprList { '[' expr? (!prec_list expr)* ']' }
  }

// precedences

@precedence {
  prec_select @left,
  prec_list @left,
  prec_callSub @left, // workaround for Sub/Negative conflict
  prec_apply @left,
  prec_neg @left,
  prec_hasAttr @left,
  prec_concat @right,
  prec_mul_div @left,
  prec_plus @left,
  prec_not @left,
  prec_update @right,
  prec_compare @left,
  prec_equal @left,
  prec_and @left,
  prec_or @left,
  prec_impl @right,

  // FIXME?
  prec_pathRelative @right,
  prec_selectOrAttrPathDot
}

@skip {
  whitespace |
  Comment |
  CommentBlock
}



// strings
// String can be multiline, but then the indent is preserved
// StringBlock is similar to python docstrings -> indent is removed

// TODO separate tokens for "${" and "}" of StringInterpolation etc

// ''string ${expr} ''${escaped} string''
StringBlockInterpolation { stringBlockInterpolationStart expr stringBlockInterpolationEnd }

// "string ${expr} \${escaped} string"
StringInterpolation { stringInterpolationStart expr stringInterpolationEnd }

@external tokens stringBlock from "./tokens" {
  StringBlockContent,
  stringBlockInterpolationStart,
  stringBlockEnd
}

@external tokens string from "./tokens" {
  StringContent,
  stringInterpolationStart,
  stringEnd
}

@skip {} {

  string_parts
    //{ ExprString { STR }
    { ExprConcatStrings { string_parts_interpolated+ }
    //| ExprString { "" } // empty string // FIXME?
    }

  ind_string_parts
    { stringBlockStart (StringBlockContent | StringBlockInterpolation)* stringBlockEnd
      // { stringBlockStart (ExprStringBlock | ExprStringBlockInterpolation)* stringBlockEnd
    }

  string_parts_interpolated
    { stringStart (StringContent | StringInterpolation)* stringEnd
      // stringStart (ExprString | ExprStringInterpolation)* stringEnd
    }

  // TODO ind_string_parts_interpolated? not in nix/src/libexpr/parser.y

  //string { String | StringBlock }
  //StringBlock { stringBlockStart (StringBlockContent | StringBlockInterpolation)* stringBlockEnd }
  //String { stringStart (StringContent | StringInterpolation)* stringEnd }
}

//path_start
//  { ExprPath { PATH }
//  | ExprPath { HOME_PATH } // if evalSettings.pureEval: Error, the path '%s' can not be resolved in pure mode
//  }

// 
// path_start
//   { Path { PathAbsolute | !prec_pathRelative PathRelative | PathLibrary | PathHome | URI }
//   }



// attribute sets

// binds
//   { ExprAttrs
//     {
//       ( Attr { attrpath '=' expr ';' }
//       | AttrInherit { INHERIT attrs ';' }
//       | AttrInheritFrom { INHERIT '(' expr ')' attrs ';' } // !!! Should ensure sharing of the expression in $4.
//       )*
//     }
//   }

// TODO restore
// 
// attrs
//   { AttrPath { ( AttrName_ExprString { string_attr } )* }
//   }
// 
// attrpath
//   { AttrName { attrpath '.' attr }
//   | AttrName_ExprString { attrpath '.' string_attr }
//   | AttrName { attr } // $$ = new std::vector<AttrName>; $$->push_back(AttrName(data->symbols.create($1)));
//   | AttrName_ExprString { string_attr }
//   }
// 
// attr
//   { Identifier (OR_KW Identifier)* }
//
// string_attr
//   //{ ('"' string_parts '"')
//   { (string_parts)
//   | ('${' expr '}')
//   }

// FIXME Unused rule 'expr_list'
// -> ExprList?
// expr_list
//  { ExprList { expr_list expr_select } // $$ = $1; $1->elems.push_back($2); // !!! dangerous
//  }

formals
  { Formals { (formal? (',' formal)* (',' '...')?) | '...' }
  }

formal
  { Formal { Identifier }
  | Formal { Identifier '?' expr }
  }



// named keywords
Keyword<term> { @specialize[@name={term}]<Identifier, term> }

// anonymous keywords
keyword<term> { @specialize<Identifier, term> }



// keywords
// need underscore for anonymous nodes

_ASSERT { keyword<"assert"> }
_IF { keyword<"if"> }
_THEN { keyword<"then"> }
_ELSE { keyword<"else"> }

WITH { keyword<"with"> }
LET { keyword<"let"> }
IN { keyword<"in"> }
OR_KW { keyword<"or"> }
INHERIT { keyword<"inherit"> }
REC { keyword<"rec"> }

_TRUE { keyword<"true"> }
_FALSE { keyword<"false"> }
_NULL { keyword<"null"> }

TRUE { keyword<"true"> }
FALSE { keyword<"false"> }
NULL { keyword<"null"> }



@tokens {
  //PATH_END { '/' } // TODO?

  //Integer { std.digit+ }
  integer { std.digit+ }

  //Float { ((std.digit+ "." std.digit+) | ("." std.digit+)) (("e" | "E") std.digit+)? }
  float   { ((std.digit+ "." std.digit+) | ("." std.digit+)) (("e" | "E") std.digit+)? }

  // note: nix allows minus in identifiers
  //identifier { identifierChar (identifierChar | std.digit | "-" )* }
  Identifier { identifierChar (identifierChar | std.digit | "-" )* }

  // TODO test
  //identifierChar { std.asciiLetter | $[_$\u{a1}-\u{10ffff}] }
  identifierChar { std.asciiLetter }

  // fix: Overlapping tokens Integer and Float
  // fix: Overlapping tokens Float and "."
  //@precedence { Float, Integer, "." }
  @precedence { float, integer, "." }

  stringBlockStart { "''" }
  stringBlockInterpolationEnd { "}" }

  stringStart { '"' }
  stringInterpolationEnd { "}" }

  // fix error: Overlapping tokens Identifier and whitespace
  // TODO why overlapping? Identifier is non-whitespace
  @precedence { Identifier, whitespace }

  whitespace { std.whitespace+ }

  // FIXME no need for whitespace after formals
  // this is valid:
  // let f={a}:a; in f{a=1;}
  // let f=a: a; in f 1
  // this is not:
  // let f=a:a; in f 1 # error: attempt to call something which is not a function but a string
  //Colon { ":" }
  //colonWithSpace { Colon std.whitespace+ }

  CommentOpen { "#" }
  Comment { CommentOpen ![\n]* }

  // TODO CommentBlockClose */
  CommentBlockOpen { "/*" }
  CommentBlock { CommentBlockOpen blockCommentRest }
  blockCommentRest { ![*] blockCommentRest | "*" blockCommentAfterStar }
  blockCommentAfterStar { "/" | "*" blockCommentAfterStar | ![/*] blockCommentRest }

  PathAbsolute { "/" pathContent }
  // fix: Overlapping tokens "/" and PathAbsolute
  @precedence { PathAbsolute, "/" }

  PathRelative { "./" pathContent }
  // fix: Overlapping tokens PathRelative and "."
  @precedence { PathRelative, "." }

  PathHome { "~/" pathContent }

  // TODO angle braces as tokens
  PathLibrary { "<" PathLibraryValue ">" }
  PathLibraryValue { pathContent }

  // TODO add more special characters?
  pathContent { (Identifier | ".")+ ("/" (Identifier | ".")+)* }

  uriSchema { std.asciiLetter (std.asciiLetter | std.digit | "+" | "-")* }
  uriPath { (std.asciiLetter | std.digit | "%" | "/" | "?" | ":" | "@" | "&" | "=" | "+" | "$" | "," | "-" | "_" | "." | "!" | "~" | "*" | "'")+ }
  URI { uriSchema ":" uriPath }

  // fix: Overlapping tokens Identifier and URI
  @precedence { URI, Identifier }

  // fix: Overlapping tokens Identifier and x
  // better?
  // kw<word> { @specialize[@name={word}]<Identifier, word> }
  @precedence {

    _IF,
    _THEN,
    _ELSE,

    _ASSERT,
    WITH,
    LET,
    IN,
    OR_KW,
    INHERIT,
    REC,

    PATH_END,

    //if, then, else,
    //assert,
    //with,
    //let,
    //in,
    //inherit,
    //URI,
    //False, True, Null,

    Identifier
    //,
    //identifier
  }
}
